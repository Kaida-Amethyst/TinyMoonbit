// Generated using `moon info`, DON'T EDIT IT
package "Kaida-Amethyst/TinyMoonBit"

import(
  "Kaida-Amethyst/MoonLLVM/IR"
  "Kaida-Amethyst/either"
)

// Values
fn fib(Int) -> Int64

// Errors
pub suberror ParseError (Token, String)
impl Show for ParseError

pub suberror TokenizeError String
impl Show for TokenizeError

pub suberror TypeCheckError String
impl Show for TypeCheckError

// Types and methods
pub struct ApplyExpr {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  mut ty : TypeKind?
  kind : ApplyExprKind
}
impl Eq for ApplyExpr
impl Show for ApplyExpr

pub enum ApplyExprKind {
  AtomExpr(AtomExpr)
  ArrayAccess(ApplyExpr, Expr)
  FieldAccess(ApplyExpr, String)
  TupleAccess(ApplyExpr, Int)
  Call(ApplyExpr, Array[Expr])
}
impl Eq for ApplyExprKind
impl Show for ApplyExprKind

pub(all) enum AssignOp {
  Assign
  PlusAssign
  MinusAssign
  MultAssign
  DivAssign
  ModAssign
}
impl Eq for AssignOp
impl Show for AssignOp
impl ToJson for AssignOp

pub struct AssignStmt {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  left_value : LeftValue
  op : AssignOp
  expr : Expr
}
impl Eq for AssignStmt
impl Show for AssignStmt

pub struct AtomExpr {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  mut ty : TypeKind?
  kind : AtomExprKind
}
impl Eq for AtomExpr
impl Show for AtomExpr

pub enum AtomExprKind {
  Int(Int)
  Int64(Int64)
  UInt(UInt)
  UInt64(UInt64)
  Float(Float)
  Double(Double)
  Bool(Bool)
  String(String)
  Ident(String)
  Unit
  Paren(Expr)
  Tuple(Array[Expr])
  Array(Array[Expr])
  StructConstruct(String, Array[(String, Expr)])
}
impl Eq for AtomExprKind
impl Show for AtomExprKind

pub(all) enum BinaryOp {
  Add
  Sub
  Mul
  Div
  Mod
  ShiftLeft
  ShiftRight
  Eq
  NE
  LT
  GT
  LE
  GE
  And
  Or
  BitAnd
  BitOr
}
impl Eq for BinaryOp
impl Show for BinaryOp

pub struct BlockExpr {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  ty : TypeKind?
  stmts : Array[Stmt]
}
impl Eq for BlockExpr
impl Show for BlockExpr

pub struct Context {
  code : String
  tokens : Array[Token]
  fatal_errors : Array[ParseError]
  normal_errors : Array[ParseError]
  top_functions : Map[String, TopFunction]
  extern_functions : Map[String, ExternFunction]
  top_lets : Map[String, TopLet]
  struct_defs : Map[String, StructDef]
  mut type_env : Env[String, TypeKind]
  mut current_func : TopFunction?
  mut name_env : Env[String, Name]
  knf_top_lets : Map[String, KnfTopLet]
  knf_ext_funcs : Map[String, KnfExternFunc]
  knf_top_funcs : Map[String, KnfFunction]
  llvm_ctx : @IR.Context
  llvm_mod : @IR.Module
  builder : @IR.IRBuilder
  llvm_funcs : Map[String, @IR.Function]
  llvm_global_values : Map[String, &@IR.GlobalValue]
  source_file : String
}
fn Context::apply_expr_to_knf(Self, ApplyExpr) -> (Array[KnfStmt], KnfExpr)
fn Context::array_access_to_knf(Self, ApplyExpr, Expr) -> (Array[KnfStmt], KnfExpr)
fn Context::assign_stmt_to_knf(Self, AssignStmt) -> Array[KnfStmt]
fn Context::atom_expr_to_knf(Self, AtomExpr) -> (Array[KnfStmt], KnfExpr)
fn Context::binary_expr_to_knf(Self, BinaryOp, Expr, Expr) -> (Array[KnfStmt], KnfExpr)
fn Context::bind_pat_and_expr_to_knf(Self, Pattern, TypeKind, KnfExpr) -> Array[KnfStmt]
fn Context::bind_pat_and_name_to_knf(Self, Pattern, TypeKind, Name) -> Array[KnfStmt]
fn Context::bind_pattern(Self, Pattern, TypeKind) -> Unit raise TypeCheckError
fn Context::block_to_knf(Self, BlockExpr) -> KnfBlock
fn Context::call_expr_to_knf(Self, ApplyExpr, Array[Expr]) -> (Array[KnfStmt], KnfExpr)
fn Context::codegen_knf_binary_expr(Self, BinaryOp, Name, Name, Map[Name, &@IR.Value], Map[Name, TypeKind]) -> &@IR.Value raise
fn Context::codegen_knf_expr(Self, KnfExpr, Map[Name, &@IR.Value], Map[Name, TypeKind]) -> &@IR.Value raise
fn Context::codegen_knf_ext_func(Self, KnfExternFunc) -> Unit raise
fn Context::codegen_knf_func(Self, KnfFunction) -> Unit raise
fn Context::codegen_knf_func_for_func_value(Self, KnfFunction) -> Unit raise
fn Context::codegen_knf_stmt(Self, KnfStmt, Map[Name, &@IR.Value], Map[Name, TypeKind]) -> Unit raise
fn Context::expr_to_knf(Self, Expr) -> (Array[KnfStmt], KnfExpr)
fn Context::field_access_to_knf(Self, ApplyExpr, String) -> (Array[KnfStmt], KnfExpr)
fn Context::for_stmt_to_knf(Self, ForStmt) -> Array[KnfStmt]
fn Context::get_error_msg(Self, Token, String) -> String
fn Context::get_ident_type(Self, String) -> TypeKind?
fn Context::get_knf_name(Self, String) -> Name
fn Context::if_expr_to_knf(Self, IfExpr) -> (Array[KnfStmt], KnfExpr)
fn Context::knf_transform(Self) -> Unit
fn Context::left_value_to_knf(Self, LeftValue) -> (Array[KnfStmt], Name)
fn Context::let_stmt_to_knf(Self, LetStmt) -> Array[KnfStmt]
fn Context::llvm_codegen(Self) -> @IR.Module raise
fn Context::multiple_exprs_to_knf(Self, Array[Expr]) -> (Array[KnfStmt], Array[Name])
fn Context::new(String, source_file? : String) -> Self
fn Context::new_name(Self, String) -> Name
fn Context::parse(Self) -> Unit raise ParseError
fn Context::parse_apply_expr(Self, ArrayView[Token]) -> (ApplyExpr, ArrayView[Token]) raise ParseError
fn Context::parse_assign_stmt(Self, ArrayView[Token]) -> (AssignStmt, ArrayView[Token]) raise ParseError
fn Context::parse_atom_expr(Self, ArrayView[Token]) -> (AtomExpr, ArrayView[Token]) raise ParseError
fn Context::parse_block_expr(Self, ArrayView[Token]) -> (BlockExpr, ArrayView[Token]) raise ParseError
fn Context::parse_expr(Self, ArrayView[Token]) -> (Expr, ArrayView[Token]) raise ParseError
fn Context::parse_extern_function(Self, ArrayView[Token]) -> (ExternFunction, ArrayView[Token]) raise ParseError
fn Context::parse_for_stmt(Self, ArrayView[Token]) -> (ForStmt, ArrayView[Token]) raise ParseError
fn Context::parse_if_expr(Self, ArrayView[Token]) -> (IfExpr, ArrayView[Token]) raise ParseError
fn Context::parse_left_value(Self, ArrayView[Token]) -> (LeftValue, ArrayView[Token]) raise ParseError
fn Context::parse_let_mut_stmt(Self, ArrayView[Token]) -> (LetMutStmt, ArrayView[Token]) raise ParseError
fn Context::parse_let_stmt(Self, ArrayView[Token]) -> (LetStmt, ArrayView[Token]) raise ParseError
fn Context::parse_param(Self, ArrayView[Token]) -> (Param, ArrayView[Token]) raise ParseError
fn Context::parse_param_list(Self, ArrayView[Token]) -> (Array[Param], ArrayView[Token]) raise ParseError
fn Context::parse_pattern(Self, ArrayView[Token]) -> (Pattern, ArrayView[Token]) raise ParseError
fn Context::parse_stmt(Self, ArrayView[Token]) -> (Stmt, ArrayView[Token]) raise ParseError
fn Context::parse_struct_def(Self, ArrayView[Token]) -> (StructDef, ArrayView[Token]) raise ParseError
fn Context::parse_struct_field(Self, ArrayView[Token]) -> (StructField, ArrayView[Token]) raise ParseError
fn Context::parse_top_function(Self, ArrayView[Token]) -> (TopFunction, ArrayView[Token]) raise ParseError
fn Context::parse_top_let(Self, ArrayView[Token]) -> (TopLet, ArrayView[Token]) raise ParseError
fn Context::parse_type(Self, ArrayView[Token]) -> (Type, ArrayView[Token]) raise ParseError
fn Context::parse_while_stmt(Self, ArrayView[Token]) -> (WhileStmt, ArrayView[Token]) raise ParseError
fn Context::pop_env(Self) -> Unit
fn Context::pop_name_env(Self) -> Unit
fn Context::print_error(Self, ParseError) -> Unit
fn Context::print_knf(Self) -> Unit
fn Context::push_env(Self) -> Unit
fn Context::push_name_env(Self) -> Unit
fn Context::set_env(Self, String, TypeKind) -> Unit
fn Context::simple_let_tuple_to_knf(Self, Array[Pattern], Array[TypeKind], Array[Expr]) -> Array[KnfStmt]
fn Context::stmt_to_knf(Self, Stmt) -> Array[KnfStmt]
fn Context::tokenize(Self) -> Unit raise TokenizeError
fn Context::top_extern_func_to_knf(Self, ExternFunction) -> KnfExternFunc
fn Context::top_function_to_knf(Self, TopFunction) -> KnfFunction
fn Context::top_let_to_knf(Self, TopLet) -> KnfTopLet
fn Context::tuple_access_to_knf(Self, ApplyExpr, Int) -> (Array[KnfStmt], KnfExpr)
fn Context::type_check_apply_expr(Self, ApplyExpr) -> TypeKind raise TypeCheckError
fn Context::type_check_array_access_expr(Self, ApplyExpr, Expr) -> TypeKind raise TypeCheckError
fn Context::type_check_assign_stmt(Self, AssignStmt) -> Unit raise TypeCheckError
fn Context::type_check_atom_expr(Self, AtomExpr) -> TypeKind raise TypeCheckError
fn Context::type_check_block(Self, BlockExpr) -> TypeKind raise TypeCheckError
fn Context::type_check_expr(Self, Expr) -> TypeKind raise TypeCheckError
fn Context::type_check_field_access_expr(Self, ApplyExpr, String) -> TypeKind raise TypeCheckError
fn Context::type_check_for_stmt(Self, ForStmt) -> Unit raise TypeCheckError
fn Context::type_check_func_call_expr(Self, ApplyExpr, Array[Expr]) -> TypeKind raise TypeCheckError
fn Context::type_check_if_expr(Self, IfExpr) -> TypeKind raise TypeCheckError
fn Context::type_check_left_value(Self, LeftValue) -> TypeKind raise TypeCheckError
fn Context::type_check_let_mut_stmt(Self, LetMutStmt) -> Unit raise TypeCheckError
fn Context::type_check_let_stmt(Self, LetStmt) -> Unit raise TypeCheckError
fn Context::type_check_return_stmt(Self, Expr) -> TypeKind raise TypeCheckError
fn Context::type_check_stmt(Self, Stmt) -> TypeKind raise TypeCheckError
fn Context::type_check_tuple_access_expr(Self, ApplyExpr, Int) -> TypeKind raise TypeCheckError
fn Context::type_check_while_stmt(Self, WhileStmt) -> Unit raise TypeCheckError
fn Context::typecheck(Self) -> Unit raise TypeCheckError
fn Context::typecheck_function(Self, TopFunction) -> Unit raise TypeCheckError
fn Context::while_stmt_to_knf(Self, WhileStmt) -> Array[KnfStmt]

pub struct Env[K, V] {
  parent : Env[K, V]?
  data : Map[K, V]
}
fn[K : Eq + Hash, V] Env::contains(Self[K, V], K) -> Bool
fn[K : Eq + Hash, V] Env::get(Self[K, V], K) -> V?
fn[K, V] Env::new(parent? : Self[K, V]?) -> Self[K, V]
fn[K : Eq + Hash, V] Env::set(Self[K, V], K, V) -> Unit
fn[K, V] Env::sub_env(Self[K, V]) -> Self[K, V]

pub struct Expr {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  mut ty : TypeKind?
  kind : ExprKind
}
impl Eq for Expr
impl Show for Expr

pub enum ExprKind {
  ApplyExpr(ApplyExpr)
  BlockExpr(BlockExpr)
  BinaryExpr(BinaryOp, Expr, Expr)
  IfExpr(IfExpr)
}
impl Eq for ExprKind
impl Show for ExprKind

pub struct ExternFunction {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  fname : String
  ffi_name : String
  params : Array[Param]
  ret_ty : Type
}
impl Eq for ExternFunction
impl Show for ExternFunction

pub struct ForStmt {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  inits : Array[(String, Expr)]
  cond : Expr?
  steps : Array[(String, AssignOp, Expr)]
  body : BlockExpr
}
impl Eq for ForStmt
impl Show for ForStmt

pub struct IfExpr {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  mut ty : TypeKind?
  cond : Expr
  then_block : BlockExpr
  else_block : @either.Either[IfExpr, BlockExpr]?
}
impl Eq for IfExpr
impl Show for IfExpr

pub(all) enum Keyword {
  Fn
  Struct
  Enum
  Let
  Mut
  If
  Else
  Match
  While
  For
  Return
  Extern
}
impl Eq for Keyword
impl Show for Keyword

pub(all) struct KnfBlock {
  stmts : Array[KnfStmt]
  final_expr : KnfExpr
}
fn KnfBlock::nested_stringify(Self) -> String
fn KnfBlock::stringify(Self, ident~ : Int) -> String

pub(all) enum KnfExpr {
  Unit
  Int(Int)
  UInt(UInt)
  Int64(Int64)
  UInt64(UInt64)
  Float(Float)
  Double(Double)
  Bool(Bool)
  String(String)
  Ident(Name)
  Binary(BinaryOp, Name, Name)
  If(KnfExpr, KnfBlock, KnfBlock)
  Not(Name)
  Neg(Name)
  Call(Name, Array[Name])
  ArrayGet(Name, Name)
  TupleGet(Name, Int)
  CreateStruct(String)
  ArrayLiteral(Array[Name])
  TupleLiteral(Array[Name])
}
fn KnfExpr::stringify(Self, ident? : Int) -> String
impl Show for KnfExpr

pub(all) struct KnfExternFunc {
  name : String
  ty : TypeKind
  params : Array[TypeKind]
}
impl Show for KnfExternFunc

pub(all) struct KnfFunction {
  name : String
  ty : TypeKind
  params : Array[(Name, TypeKind)]
  body : KnfBlock
  name_value_map : Map[Name, &@IR.Value]
  name_type_map : Map[Name, TypeKind]
}
fn KnfFunction::stringify(Self) -> String
impl Show for KnfFunction

pub(all) enum KnfStmt {
  Let(Name, TypeKind, KnfExpr)
  LetMut(Name, TypeKind, KnfExpr)
  Assign(Name, Name)
  ArrayPut(Name, Name, KnfExpr)
  StructSet(Name, String, KnfExpr)
  While(KnfBlock, KnfBlock)
  ExprStmt(KnfExpr)
  Return(KnfExpr)
  ReturnVoid
}
fn KnfStmt::stringify(Self, ident? : Int) -> String
impl Show for KnfStmt

pub(all) struct KnfStructDef {
  name : String
  fields : Array[(String, TypeKind)]
}

pub(all) struct KnfTopLet {
  name : Name
  ty : TypeKind
  is_mut : Bool
  expr : KnfExpr
}
impl Show for KnfTopLet

pub struct LeftValue {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  kind : LeftValueKind
  mut ty : TypeKind?
}
impl Eq for LeftValue
impl Show for LeftValue

pub enum LeftValueKind {
  Ident(String)
  ArrayAccess(LeftValue, Expr)
  FieldAccess(LeftValue, String)
}
impl Eq for LeftValueKind
impl Show for LeftValueKind

pub struct LetMutStmt {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  name : String
  mut ty : Type?
  expr : Expr
}
impl Eq for LetMutStmt
impl Show for LetMutStmt

pub struct LetStmt {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  pattern : Pattern
  mut ty : Type?
  expr : Expr
}
impl Eq for LetStmt
impl Show for LetStmt

pub(all) struct Name {
  id : String
  slot : Int
}
fn Name::is_wild_card(Self) -> Bool
fn Name::new_wild_card() -> Self
impl Eq for Name
impl Hash for Name
impl Show for Name

pub struct Param {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  name : String
  ty : Type
}
impl Eq for Param
impl Show for Param

pub struct Pattern {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  kind : PatternKind
}
impl Eq for Pattern
impl Show for Pattern

pub enum PatternKind {
  Wildcard
  Ident(String)
  Tuple(Array[Pattern])
}
impl Eq for PatternKind
impl Show for PatternKind

pub struct Stmt {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  kind : StmtKind
}
impl Eq for Stmt
impl Show for Stmt

pub enum StmtKind {
  LetStmt(LetStmt)
  LetMutStmt(LetMutStmt)
  AssignStmt(AssignStmt)
  WhileStmt(WhileStmt)
  ForStmt(ForStmt)
  ExprStmt(Expr)
  ReturnStmt(Expr?)
}
impl Eq for StmtKind
impl Show for StmtKind

pub struct StructDef {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  name : String
  generic_params : Array[String]
  fields : Array[StructField]
}
impl Eq for StructDef
impl Show for StructDef

pub struct StructField {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  name : String
  ty : Type
}
impl Eq for StructField
impl Show for StructField

pub struct Token {
  kind : TokenKind
  lineno : Int
  column : Int
}
fn Token::new(TokenKind, Int, Int) -> Self
impl Eq for Token
impl Show for Token

pub(all) enum TokenKind {
  Bool(Bool)
  Int(Int)
  Int64(Int64)
  UInt(UInt)
  UInt64(UInt64)
  Float(Float)
  Double(Double)
  String(String)
  Keyword(Keyword)
  Upper(String)
  Lower(String)
  BinaryOp(BinaryOp)
  AssignOp(AssignOp)
  Not
  Bracket(Char)
  Dot
  Comma
  Colon
  DoubleColon
  SemiColon
  RightArrow
  FatRightArrow
  Wildcard
  EOF
}
impl Eq for TokenKind
impl Show for TokenKind

pub struct TopFunction {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  fname : String
  param_list : Array[Param]
  ret_ty : Type
  body : BlockExpr
}
impl Eq for TopFunction
impl Show for TopFunction

pub struct TopLet {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  name : String
  is_mut : Bool
  ty : Type
  expr : Expr
}
impl Eq for TopLet
impl Show for TopLet

pub struct Type {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  kind : TypeKind
}
impl Eq for Type
impl Show for Type

pub(all) enum TypeKind {
  Unit
  Bool
  Int
  Int64
  UInt
  UInt64
  Float
  Double
  String
  Tuple(Array[TypeKind])
  Array(TypeKind)
  Function(Array[TypeKind], TypeKind)
  Defined(String, Array[TypeKind])
}
impl Eq for TypeKind
impl Show for TypeKind

pub struct WhileStmt {
  lineno : Int
  column : Int
  end_lineno : Int
  end_column : Int
  cond : Expr
  body : BlockExpr
}
impl Eq for WhileStmt
impl Show for WhileStmt

// Type aliases

// Traits

